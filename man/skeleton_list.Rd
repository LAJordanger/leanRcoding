% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/skeleton_list.R
\name{skeleton_list}
\alias{skeleton_list}
\title{Create an empty recursive skeleton list.}
\usage{
skeleton_list(names_list, default_content = NULL,
  add_names_list_as_attribute = TRUE, compact = FALSE)
}
\arguments{
\item{names_list}{A list-object containing vectors with the names
to be used on the different levels (unique content required),
where the rule is that the first component contains the names
to be used at the top-level, and so on.  If \code{names_list}
is a vector, then an ordinary list will be created with names
in accordance with those in the vector.  Note that any
\code{names}-attributes from \code{names_list} will be
discarded in the construction of the new list.  The list given
to \code{names_list} must be a named list if the argument
\code{compact} is \code{TRUE}.}

\item{default_content}{Use this argument to specify a desired
default for the "nodes" of the recursive list.  The default
selection for this argument is \code{NULL}.}

\item{add_names_list_as_attribute}{Logic value, default
\code{TRUE}, that will add the attribute
\code{names_list} to the new list and assign
\code{names_list} as its value.}

\item{compact}{Logical value, default \code{FALSE}.  This argument
can be used to create a version of the result where the names
are suppressed in exchange for an index-function (added as an
attribute) that can find the correct level based on the names
that normally would have been used.  Note that
\code{names_list} must have unique names when \code{compact} is
given as \code{TRUE}.  If \code{names_list} is a vector, then
this argument will be ignored.}
}
\value{
A (recursive) list with names in accordance with those
    given in \code{names_list}, or with an index-function-attribute
    as described for the \code{compact}-argument.
}
\description{
Sometimes it's convenient to store stuff in lists, i.e. if the
stuff of interest contains attributes that might be needed in later
functions.  When these lists are recursive, this function can
simplify the remaining code by creating a skeleton for the desired
structure, based on the names to be used at the different levels.
}
