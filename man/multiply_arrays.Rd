% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiply_arrays.R
\name{multiply_arrays}
\alias{multiply_arrays}
\title{Multiply arrays based on dimension-names, using recycling}
\usage{
multiply_arrays(.arr1, .arr2, keep_shape = FALSE)
}
\arguments{
\item{.arr1}{The first array in the product, if \code{.arr2} has
the same size (but not necessarily the same shape), the result
will be given in the shape of \code{.arr1}.  The case where
\code{.arr1} is a single number (dimensionless) will be treated
as an exception, in which case that single number will be
multiplied with \code{.arr2}.}

\item{.arr2}{The second array in the product.  The case where
\code{.arr2} is a single number (dimensionless) will be treated
as an exception, in which case that single number will be
multiplied with \code{.arr1}.}

\item{keep_shape}{A logic argument, default value \code{FALSE} that
only is used when recycling is needed in order to perform the
product.  If the shape of the resulting array doesn't matter,
then the default will avoid an extra permutation at the end of
the computation.}
}
\value{
When \code{.arr1} and \code{.arr2} have the same size, the
    result will be the product of them in the shape of
    \code{.arr1}.  If one of them has fewer dimensions than the
    other, then recycling will be performed and the result will be
    given in the shape of the largest one.  It is allowed to have
    as an exception the case where one (or both) of the
    array-arguments is a single number (dimensionless), in which
    case a standard product will be performed.
}
\description{
Given two arrays with a full set of named dimension-names that
match in a proper fashion, this function will create the product of
them based on matching dimension-names.  If necessary, an
intermediate step will be performed to properly align the arrays.
If one array has fewer dimensions than the other, then the product
will be performed by recycling of vectors.
}
